
# R on andmeanalüüsi keel, mille verbid on funktsioonid

Kasutaja ütleb nii täpselt kui oskab, mida ta tahab ja R-s elab kratt, kes püüab ära arvata, mida on vaja teha. 
Vahest teeb kah. 
Vahest isegi seda, mida kasutaja tahtis. 
R-i puudus on veateadete puudumine või krüptilised veateated. 
Sama kehtib ka R-i helpi kohta. 
Seega tasub alati kontrollida, kas R ikka tegi seda, mida sina talle enda arust ette kirjutasid.

```{r}
x <- c(6, 3, 3, 4, 5)
y <- c(1, 3, 4, 2, 7)
cor(x, y) # correlation
sum(x)
sum(x, y)
mean(x)
median(x)
quantile(x)
sd(x) # standard deviation - goes with mean
max(x)
min(x)
```

R-is teevad asju programmikesed, mida kutsutakse **funktsioonideks**. 
Te võite mõelda funktsioonist nagu verbist. 
Näiteks `sum()` loe: "võta summa". 
Teie ütlete, kratt teeb. Iga funktsiooni nime järel on sulud. 
Nende sulgude sees asuvad selle funktsiooni **argumendid**. 
Et näha, millised argumendid seal on

```{r}
?sum
```


Help paneelis paremal all ilmub nüüd selle funktsiooni help page. Vt seal peatükki Usage: `sum(..., na.rm = FALSE)` ja edasi ptk Arguments, mis ütleb, et `...` (ellipsis) tähistab vektoreid. 

------------------------
------------------------

sum {base}	R Documentation 
Sum of Vector Elements

**Description:** 

sum returns the sum of all the values present in its arguments.

**Usage**

sum(..., na.rm = FALSE)

**Arguments**

...	- numeric or complex or logical vectors.

na.rm	- logical. Should missing values (including NaN) be removed?

------------------------
------------------------


Seega võtab funktsioon `sum()` 2 argumenti: vektori arvudest (või loogilise vektori, mis koosneb TRUE ja FALSE määrangutest), ning na.rm argumendi, millele saab anda 2 väärtust, TRUE või FALSE. Usage ütleb ka, et na.rm = FALSE, mis tähendab, et sellele argumendile on antud vaikeväärtus -- kui me seda ise ei muuda, siis jäävad NA-d arvutusse sisse. Kuna NA tähendab "tundmatu arv" siis iga tehe NA-dega annab vastuseks "tundmatu arv" ehk NA (tundmatu arv + 2 = tundmatu arv). Seega NA tulemus annab märku, et teie andmetes võib olla midagi valesti.


```{r}
apples <- c(1, 34, 43, NA) #c() --- combine() on ise funktsioon
#?c #proovi seda
sum(apples, na.rm = TRUE)

```
Niimoodi saab arvutada summat vektorile nimega apples.

evalueerides funktsiooni ilma selle sulgudeta saab masinast selle funktsiooni koodi. Näiteks:
```{r}
sum
```
See ei ole küll liiga kasulik...

### Kirjutame oma esimese funktsiooni

Põhjus, miks R-s on funktsioonid, on ruumi kokkuhoid. 
Funktsiooni ainus mõte on peita teie eest kood funktsiooni nime taha. 
See muudab pikad koodilõigud hõlpsalt taaskasutatavaks sest lihtsam on kirjutada lühike funktsiooni nimi ja sisestada selle funktsiooni argumendid, kui copy-pastida n rida koodi ja siis muuta selle sees mingeid väärtusi. 
Koodi funktsioonidesse kokku surumine vähendab võimalusi lollideks vigadeks, mida te võite teha pikkade koodijuppidega manipuleerides. 
Seega tasub teil õppida ka oma koodi funktsioonidena vormistama.

Kõige pealt kirjutame natuke koodi.
```{r}
apples <- 2 #two apples
oranges <- 3 #three oranges
(inventory <- apples + oranges)
```
 
Ja nüüd teeme sellest funktsiooni `inventory()`. 
Seda koodi jooksutades näeme, et meie funktsioon ilmub R-i Environmenti, kuhu tekib Functions lahter. 
Seal on näha ka selle funktsiooni kaks argumenti, apples ja oranges.
 
Funktsiooni kirjutamiseks anname kõigepealt sellele nime ja kirjutame selle ilma sulgudeta. 
Siis tuleb `<-` ( __assignment operator__ ), misjärel `function(arg1, arg2, ...)`. Siis algavad loogelised sulud { }, mille sisse kirjutame oma koodi. Viimane koodirida on see, mis tuleb välja selle funktsiooni outputina. Antud juhul on selleks print(inventory), ehkki print() ei pea siia kirjutama sest R saab sellest ise aru.
 
```{r}
inventory <- function(apples, oranges) {
  inventory <- apples + oranges
  inventory
}
```

Andes funktsiooni argumentidele väärtused, saab väljundi:
```{r}
inventory(2, 3) 
```
Seega asendasime me kolm rida koodi ühega, mis on hea algus.

Nüüd midagi kasulikumat. Funktsioon standrardvea arvutamiseks (baas R-s sellist funktsiooni ei ole)

sd() annab standardhälbe. Sellel on 2 argumenti. vt Help-i.
Me teame, et SEM=SD/sqrt(N)
kus N = length(x)
```{r}
SEM0 <- function(x) {
  SD <- sd(x)
  SEM <- SD / sqrt(length(x))
  SEM
}
```

x hoiab lihtsalt kohta andmetele, mida me tahame sinna funktsiooni suunata.
`sd()`, `sqrt()` ja `length()` on olemasolevad baas R funktsioonid, mille me oma funktsiooni hõlmame.

```{r}
numbers<- c(2, 3.4, 54, NA, 3) #c() means "combine", NA means "any number" or "not available"
SEM0(numbers)
```
No jah, kui meil on andmetes tundmatu arv (NA) siis on ka tulemuseks tundmatu arv.

Teeme uue versiooni oma funktsioonist
```{r}
SEM01<- function(x) {
  SD<- sd(x, na.rm = TRUE) 
  SEM<- SD/sqrt(length(x))
  SEM
}
SEM01(numbers)
length(numbers)
```

See annab meile vale tulemuse sest na.rm=TRUE viskab välja NA-d meie vektorist aga jätab vektori pikkuse muutmata. Piinlik lugu aga meil tuleb veelkord proovida. Seekord võtame vektorist NA-d välja ja töötame edasi uue lühema vektoriga. Siis klapib ka vektori pikkus 

```{r}
SEM1<- function(x) {
  x1<- na.omit(x) #you want NAs to be removed
  SD<- sd(x1) 
  SEM<- SD/sqrt(length(x1))
  SEM
}
SEM1(numbers)
```

Olgu see õpetuseks, et funktsioonide kirjutamine on järk-järguline protsess ja sellele, et alati saab paremini teha.